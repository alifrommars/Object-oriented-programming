# Наследяване (inheritance) – трети принцип на ООП

При създаване на нов клас, който има общи компоненти и поведение с вече дефиниран клас, вместо новият клас да дефинира повторно тези компоненти и поведение, можем да го обявим за наследник на вече съществуващия и да използваме функционалността на последния.  

**Пример** за наследяване:
```c++
class Person
{
private:
	char* name;
	unsigned int age;

	// ...

public:
	void setName(const char* name);
	void setAge(unsigned int age);

	const char* getName() const;
	unsigned int getAge() const;

	// ...
};

class Student : public Person
{
private:
	unsigned int fn;

public:
	void setFn(unsigned int fn);
	unsigned int getFn() const;
};
```

Класът-наследник (Student):
- съдържа всички член-данни и методи на основните класове (Person);
- получава достъп до **някои** от наследените компоненти на основните класове (Person).

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_10/images/Student.png)

След като Student е наследник на Person, то при създаване на обект от тип Student се създава обект от тип Person, **който е част от обекта** от тип Student.

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_10/images/PersonStudent.png)

## Видове наследяване

- private (по подразбиране)
- protected
- public

```c++
class A
{
public:
    int x;
protected:
    int y;
private:
    int z;
};

class B : public A
{
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A
{
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A
{
    // x is private
    // y is private
    // z is not accessible from D
};
```

( **Втора разлика между класове и структури:** Наследяването **при класове е private** по подразбиране, а **при структури – public** по подразбиране. )

## Подаване на базови класове и класове-наследници като параметри на функции

```c++
class A
{
public:
    int a;
};
class B : public A
{
public:
    int b;
};

void f(A& obj)
{
    obj.a++;
}
void g(B& obj)
{
    obj.b++;
}

int main()
{
    A obj1;
    B obj2;

    f(obj1); // OK!
    f(obj2); // OK!

    g(obj2); // OK!
    // g(obj1); // Error!
}
```

**Извод:** Класове-наследници **могат** да бъдат подавани като параметри на функции, които приемат обекти от базовия клас. Обратното е незвъзможно :bangbang:  

Същите правила важат, ако функциите приемат **A\* obj**/**B\* obj**.

## Конструктори и деструктори при наследяване

- Във всеки конструктор на класа-наследник трябва да се оказва кой конструктор да се извика на базовия клас. Ако не е указано, ще се извика конструкторът му по подразбиране **(такъв трябва да има!**).

```c++
class B : public A
{
private:
	// ...

public:
	B(...) : A(...) // constructor of A
	{
		// initialize ONLY the data members which are specific for B
	}
};
```

- Деструкторът на класа-наследник извиква деструктора на базовия клас. **Първо се изтриват данните на наследника, после на родителя**!

## Копиране при наследяване

При разписване на конструктора за копиране и оператора за присовяване на клас-наследник трябва експлицитно да извикаме съответно копиращия конструктор и оператора за присвояване на базовия клас.

```c++
B::B(const B& other) : A(other) // copy constructor of A
{
    copyFrom(other);
}

B& B::operator=(const B& other)
{
    if (this != &other)
    {
        A::operator=(other); // operator= of A

        free();
        copyFrom(other);
    }
    return *this;
}
```

Разписваме копирането и триенето **само ако наследникът ползва необработена динамична памет** :bangbang:

### Задача:
Да се реализира клас **SetOfNumbers**, който представлява множество от числа в диапазона от 0 до n, където n се подава при създаване на класа. Съдържащите се числа трябва да бъдат кодирани като битове, за да може операциите върху тях да са максимално бързи (да се използват максимално много побитови операции). Например, мн-вото {3, 4, 6} ще се кодира като битовете 00011010, а {1, 8, 9} като 01000000 11000000.

Класът трябва да съдържа поне следните методи:

- Член-функция за добавяне на число;
- Член-функция за премахване на число;
- Член-функция за проверка дали число съществува;
- Член-функция, която приема друго множество и връща обединението на двете мн-ва;
- Член-функция, която приема друго множество и връща сечението на двете мн-ва;
- Оператор <<, който отпечатва елементите на множеството.

Разширете задачата като имплементирате клас **SetOfNumbersByCriteria**, който представлява множество от цели числа в диапазона от 0 до n, филтрирани по дадени критерии. Конструкторът на класа трябва да приема три параметъра – цяло число n (максималното число в множеството) и два булеви предиката: първият ще ни показва кои числа трябва да включим към множеството, а вторият – кои от числата, включени от първия предикат, трябва да изключим от финалния резултат. Класът трябва да поддържа и член-функция за проверка дали число съществува, както и оператор за отпечатване на елементите.  
 
Пример:
 ```c++
int main()
{
	SetOfNumbersByCriteria s(10, isPrime, isOdd);
	std::cout << s; // {2}
}
 ```
