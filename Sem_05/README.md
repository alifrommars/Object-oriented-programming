# Процес на компилация (oversimplified)

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_05/images/Compilation.png)

Нека нашият код се намира във файл с име Source.cpp. Как ще получим Source.exe?  
*Source.cpp* ->
1. **Препроцесор** – обработва препроцесорните директиви - #include, #define и други;
2. **Токенизация** – премахване на спейсове, табове, нови редове, коментари и т.н.;
3. **Синтактичен анализ** – проверка дали синтакисът на кода е валиден (чрез синтактични дървета);
4. **Семантичен анализ** – проверка дали семантиката на кода е валидна. Например, ако имате присвояване на някаква променлива на друга от несъвместим тип, в тази фаза ще се генерира грешка от вида "Assignment of incompatible type";
5. **Междинни генерализирани оптимизации** (cpu independent) – в тази фаза, ако имате проверки от вида на if (10 > 5) {...}, те ще се заменят директно с тялото на оператора (dead code elimination). Ще се случат и редица други оптимизации – loop optimization и т.н.;
6. **Генериране на assembly код**;
7. **Генериране на машинен код** за архитектурата от асемблер;
8. **Линкване** – събиране на всички .obj файлове и външни библиотеки;
9. **Още оптимизации** (cpu dependent)

-> *Source.exe*

---

# Разделна компилация

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_05/images/HeaderAndCpp.png)

Какви грешки ще получим, изпълнявайки следните програмни фрагменти?  

1. 
```c++
int main()
{
	f();
	return 0;
}

int f()
{
	return 5;
}
```
**Компилаторът** дава грешка!  

2. 
```c++
int f();

int main()
{
	f();
	return 0;
}
```
**Линкерът** дава грешка!  

Всеки .cpp файл се обработва самостоятелно, без "да знае" за съществуването на останалите :bangbang:  

Ако имаме два .cpp файла, единият с код:
```c++
int f()
{
	return 5;
}
```
а другият:
```c++
int main()
{
	f();
	return 0;
}
```
отново ще получим **грешка на компилатора** по причината, спомената по- горе.  

Нека отново имаме два .cpp файла (first.cpp, second.cpp), единият с код:
```c++
int f()
{
	return 5;
}
```
а другият:
```c++
int f();

int main()
{
	f();
	return 0;
}
```
Какво ще се случи? Успешна компилация. :heavy_check_mark:

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_05/images/Linking.png)

---

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_05/images/Compilation2.png)

Една програма на С++ може да бъде разбита в множество файлове, които **се компилират независимо един от друг**, т.е. се осъществява **разделна компилация**. В резултат на компилацията се получават няколко **обектни файла** (файлове с разширение **.obj**). Изпълнимият код на програмата (файл с разширение **.ехе**) се получава след свързване (**linking**) на обектните файлове (и външните библиотеки).  

За да се възполваме максимално от разделната компилация, разделяме класовете на **.h** и **.cpp** файлове. Навсякъде, където работим с класа, ще включваме **само .h файла**. По този начин, ако променим реализацията на някоя от функциите на класа, ще се  **прекомпилира само този файл**.  

---

## Guards

Какво ще се случи, ако добавим един хедър повече от веднъж в даден файл?

```c++
// unguarded.h
void f(){}
```

```c++
// main.cpp
#include "unguarded.h"
#include "unguarded.h"

int main()
{
    f();
}
```

Получаваме следната грешка:

```
In file included from oop.cpp:2:
unguarded.h:1:6: error: redefinition of 'void func()'
    1 | void f(){}
      |      ^~~~
In file included from oop.cpp:1:
unguarded.h:1:6: note: 'void func()' previously defined here
    1 | void f(){}
      |      ^~~~
```

Имаме два начина да решим възникналия проблем:

- ifndef guard-ове
```c++
// guarded.h
#ifndef _GUARDED_H_
#define _GUARDED_H_

void func(){}

#endif // _GUARDED_H_
```

```c++
#include "guarded.h"
#include "guarded.h"

int main()
{
    func();
}
```

- препроцесорната директива #pragma once
```c++
// guarded.h
#pragma once

void func(){}
```

```c++
#include "guarded.h"
#include "guarded.h"

int main()
{
    func();
}
```

Директивата **#pragma once** следи за това файла с дадено име да се добавя само веднъж по време на компилация. С други думи, прави същото като #ifndef guard-а, но по-ефективно. Единственият проблем на тази клауза е, че е compiler specific. Тоест, ако кодът трябва да работи на всякакви платформи и да бъде компилиран от различни компилатори, по-добре е да се използва #ifndef.

---

## Задача 1:
Да се реализира **class Time** за работа с часове.  
Класът трябва да съдържа поне следните методи:
- Подразбиращ се контруктор, който създава часа на 00:00:00.
- Конструктор, който приема три параметъра – час, минути и секунди.
- Член-функция, която увеличава часа с 1 секунда.
- Член-функция за принтиране на часа.
- Член-функция, която връща оставащото време до полунощ.
- Член-функция, която връща дали е време за вечеря. В рамките на задачата време за вечеря е между 20:30 и 22:00.
- Член-функция, която връща дали е време за купон. В рамките на задачата време за купон е между 23:00 и 06:00.
- Функция, която приема два обекта от тип Time и ги сравнява.

## Задача 2:
Да се реализира **class Date** за работа с дати.  
Класът трябва да съдържа поне следните методи:

- Конструктор, който приема три параметъра – година, месец и ден.
- Гетъри и сетъри за всички член-данни.
- Член-функция, която връща кой ден от седмицата е (понеделник-неделя).
- Член-функция, която връща следващата дата.
- Член-функция за принтиране на датата.
- Функция, която приема два обекта от тип Date и ги сравнява.

## Задача 3:
Да се реализира **class Event** за работа със събития.  
Класът трябва да съдържа поне следните методи:

- Конструктор, който приема четири параметъра – име на събитието, дата на провеждане, начален и краен час.
- Гетъри за всички член-данни.
- Член-функция, която връща през кой ден от седмицата се провежда събитието (понеделник-неделя).
- Член-функция за принтиране на събитието.

## Задача 4:
Да се реализира **class EventCollection** за работа с колекция от събития.  
Класът трябва да съдържа поне следните методи:

- Член-функция за добавяне на събитие.
- Член-функция за премахване на събитие по име.
- Член-функция за намиране на най-дългото събитие.
- Член-функция, която приема дата и връща максималния брой събития, които може да се посетят в този ден (за да се посетят 2 събития, те не трябва да се пресичат).

:bangbang: В задачите да се спазва принципа за **разделна компилация**.  
