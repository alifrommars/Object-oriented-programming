# Голямата четворка (Big 4)

- Конструктор по подразбиране (Default constructor)
- Конструктор за копиране (Copy constructor)
- Оператор= (Copy assignment operator)
- Деструктор (Destructor)

Да разгледаме следната структура:
```c++
struct Test
{
	int valueX;
	int valueY;
};
```
Понеже функциите от голямата четворка не са дефинирани в структурата, компилаторът ще създаде такива.  
**Пример:**
```c++
int main()
{
	Test a, b; // Default constructors for a and b
	Test c(a); // Default copy constructor for c (c.valueX = a.valueX, c.valueY = a.valueY is what the compiler does)
	a = b;     // Default copy assignment operator for a
}                  // Default destructors for a, b and c
```
Кодът се компилира успешно и функциите имат правилно поведение.

### Как работят дефинираните от компилатора функции от голямата четворка?

Всяка една от тези функции **извиква същите функции върху член-данните.**
```c++
struct Test
{	
	A obj1;
	B obj2;
	C obj3;
};
```

#### Пример за конструктора по подразбиране:
![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_06/images/Constr.png)

#### Пример за деструктора:
![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_06/images/Destr.png)

#### Пример за копиращия конструктор:
![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_06/images/CopyConstr.png)

### Проблем при функциите, генерирани от компилатора:
Да разгледаме следния код:
```c++
class Person
{
private:
    char* name;
    unsigned int age;

public:
    Person(const char* name, unsigned int age)
    {
    	if (name == nullptr || age == 0)
	{
		return;
	}
        this->name = new char[strlen(name) + 1];
        strcpy(this->name, name);
        this->age = age;
    }
};

int main()
{
    Person p1;
    Person p2(p1); // p2 is a shallow copy of p1
}
```
Копиращият конструктор, създаден от компилатора, има **неправилно поведение**. :x:

Създаденото копие се нарича **shallow copy**. В p2 **сме копирали указателя, а не самото име** на p1, което води до споделяне на обща динамична памет. В тази ситуация **трябва да се имплементират експлицитно** ***копиращия конструктор***, ***оператора за присвояване*** и ***деструктора***, защото генерираните от компилатора не работят правилно.

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_06/images/ShallowCopy.png)

**Правилното поведение** на копиращия конструктор е следното: :heavy_check_mark:

![alt_text](https://github.com/MariaGrozdeva/Object-oriented_programming_FMI/blob/main/Sem_06/images/RealCopy.png)

## Собствена имплементация на голямата четворка
```c++
// ...

Person::Person()
{}
Person::Person(const Person& other)
{
	copyFrom(other);
}
Person& Person::operator=(const Person& other)
{
	if (this != &other)
	{
		free();
		copyFrom(other);
	}
	return *this;
}
Person::~Person()
{
	free();
}

void Person::copyFrom(const Person& other)
{
	name = new char[strlen(other.name) + 1];
	strcpy(name, other.name);

	age = other.age;
}
void Person::free()
{
	delete[] name;
}

// ...
```

## Задачи

### Задача 1:
Да се реализира **class GraduatedStudent** - клас, описващ дипломирал се студент. Студентът се характеризира с:  
- име (символен низ с произволна дължина);
- масив от оценки (всеки студент може да има различен брой оценки);
- цитат (низ с дължина до 32 символа);
- трябва да се пази информация за средния успех на всички **живи** обекти – завършили студенти. Средният успех е сума от средните успехи на индивидуалните студенти, разделена на броя им.

Класът трябва да съдържа поне следните методи:
- Конструктор с параметри – име, оценки и цитат.
- Сетъри за всички член-данни.
- Гетъри за всички член-данни (включително за средния успех на индивидуален студент, за средния успех на всички завършили студенти и за общия им брой).

### Задача 2:
Да се реализира **class Set** - клас, който съдържа множество от числа (без повторения) в диапазона от 0 до n-1, където n е произволно. Класът трябва да пази информация за числата, които съдържа, в битове, т.е. ако съдържа дадено число, съответвеният последователен бит ще бъде 1, в противен случай – 0. Например:
- {3, 4, 6} => 00011010
- {1, 8, 9} => 01000000 11000000

Класът трябва да съдържа поне следните методи:
- Конструктор с единствен параметър – големината на множеството n.
- Член-функция за добавяне на число.
- Член-функция за премахване на число.
- Член-функция, която проверява дали дадено число е в множеството.
- Член-функция за принтиране на множеството.
- Функция, която приема две множества и връща тяхното обединение.
- Функция, която приема две множества и връща тяхното сечение.

---

# Статични член-данни и член-функции

Когато се създава обект от даден клас, този обект разполага със **свое собствено копие** на член-данните. Когато обаче член-данните са декларирани като **статични (с ключовата дума static)**, те се **споделят от всички обекти на класа**.  

Характеристики на **статичните член-данни**:
1. Статичните член-данни се **декларират в класа**. Преди да бъдат използвани, те трябва да бъдат дефинирани и инициализирани. Освен в някои случаи, това се случва извън декларацията на класа.
2. Памет за статичните член-данни се заделя не върху стека, а в **областта за статични данни**.
3. **Памет за статичните член-данни се заделя еднократно**. Всички обекти от класа имат достъп до нея.
4. Статичните член-данни се създават, когато се стартира програмата и се унищожават, когато програмата приключи. Тъй като те съществуват преди изобщо да има създадени обекти от класа, **те се свързват със самия клас, а не с някой конкретен обект**. Най-добре е достъпът до тях да се осъществява през класа (с оператор за принадлежност ::), а не през обект.  

Характеристики на **статичните член-функции**:
1. Тъй като статичните член-функции могат да бъдат извикани през самия клас, дори без да
съществуват обекти от този клас, то **в тях няма дефиниран указател this**.
2. След като не се изпълняват върху конкретен текущ обект, то в тях не могат да се използват
други член-данни на класа, които не са статични. **В статичните член-функции могат да се
използват само статични член-данни**.
3. Статичните член-функции **не могат да бъдат константни**. Причината отново е, че не се
изпълняват върху конкретен текущ обект.
4. Препоръчително е статичните член-функции (както и статичните член-данни) да бъдат
използвани **само с пълното име на класа, а не през обект**.

## Задача:
Да се реализира клас ObjectCounter, който **следи броя на живите си обекти**.  Всеки обект има свой уникален идентификатор - цяло неотрицателно число. Броят на живите обекти НЕ може да бъде деклариран като обикновена член-данна. Той трябва да се променя (достъпва) при създаването на обект от съответния конструктор, както и при унищожаването на обект от деструктора на класа.
